<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../frontend/assets/css/style.css">
  <title>Document</title>

</head>

<body>

  <div>
    <iframe src="../../frontend/assets/pages/menu.html" frameborder="0" class="flame"></iframe>
  </div>
  <section class="container">
    <h1>useAsync</h1>
    <p>
      Nesta série de artigos, embarcamos em uma jornada pelo reino dos ganchos React personalizados, descobrindo seu
      imenso potencial para elevar seus projetos de desenvolvimento. Nosso foco hoje está no gancho "useAsync", um dos
      muitos ganchos cuidadosamente criados disponíveis na coleção de ganchos personalizados React.
    </p>
    <div class="exemplos">
      import { useCallback, useEffect, useState } from "react" <br>
      <br>
      export default function useAsync(callback, dependencies = []) {<br>
      const [loading, setLoading] = useState(true)<br>
      const [error, setError] = useState()<br>
      const [value, setValue] = useState()<br>
      <br>
      const callbackMemoized = useCallback(() => {<br>
      setLoading(true)<br>
      setError(undefined)<br>
      setValue(undefined)<br>
      callback()<br>
      .then(setValue)<br>
      .catch(setError)<br>
      .finally(() => setLoading(false))<br>
      }, dependencies)<br>
      <br>
      useEffect(() => {<br>
      callbackMemoized()<br>
      }, [callbackMemoized])<br>
      <br>
      return { loading, error, value }<br>
      }
    </div>
  </section>

</body>

</html>
