<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../frontend/assets/css/style.css">
  <title>Document</title>

</head>

<body>

  <div>
    <iframe src="../../frontend/assets/pages/menu.html" frameborder="0" class="flame"></iframe>
  </div>
  <section class="container">

    <h1>useRef</h1>
    <a href="https://react-dev.translate.goog/reference/react/useRef?_x_tr_sl=en&_x_tr_tl=pt&_x_tr_hl=pt-BR&_x_tr_pto=sc&_x_tr_hist=true"
      style="text-decoration: none;">Fonte: useRef - React</a>
    <p>
      <strong>useRef</strong> é um React Hook que permite referenciar um valor que não é necessário para renderização.
    </p>
    <div class="exemplos">
      const ref = useRef(initialValue)
    </div>
    <h2>Referência</h2>
    <h4>useRef(initialValue) </h4>
    <p>
      Chame useRef no nível superior do seu componente para declarar uma ref.
      <div class="anotacoes">
        import { useRef } from 'react'; <br>
        <br>
        function MyComponent() {<br>
        const intervalRef = useRef(0);<br>
        const inputRef = useRef(null); <br>
        /......
      </div>
    </p>
    <hr>
    <h3>Exemplo feito</h3>
    <p>
      
    </p>
    <hr>
    <h4>Parâmetros</h4>
    <ul>
      <li>
        <strong>initial Value:</strong> O valor que você deseja que a propriedade do objeto ref currenttenha
        inicialmente. Pode ser um
        valor de qualquer tipo. Este argumento é ignorado após a renderização inicial.
      </li>
    </ul>
    <h4>Devoluções</h4>
    <p>
      <strong>useRef</strong> retorna um objeto com uma única propriedade:
      <ul>
        <li>current: Inicialmente, está definido como initialValuevocê passou. Mais tarde, você pode configurá-lo para
          outra coisa. Se você passar o objeto ref para o React como um refatributo para um nó JSX, o React definirá sua
          currentpropriedade.</li>
      </ul>
      Nas próximas renderizações,<strong>useRef</strong> retornará o mesmo objeto.
    </p>
    <h4>Ressalvas</h4>
    <ul>
      <li>
        Você pode alterar a ref.currentpropriedade. Ao contrário do estado, é mutável. No entanto, se ele contiver um
        objeto usado para renderização (por exemplo, uma parte do seu estado), você não deverá alterar esse objeto.
      </li>
      <hr>
      <li>
        Quando você altera a ref.currentpropriedade, o React não renderiza novamente seu componente. O React não percebe
        quando você o altera porque um ref é um objeto JavaScript simples.
      </li>
      <hr>
      <li>
        Não escreva ou leia ref.current durante a renderização, exceto durante a inicialização. Isso torna o
        comportamento do seu componente imprevisível.
      </li>
      <hr>
      <li>
        No Modo Estrito, o React chamará a função do seu componente duas vezes para ajudá-lo a encontrar impurezas
        acidentais. Este é um comportamento apenas de desenvolvimento e não afeta a produção. Cada objeto ref será
        criado duas vezes, mas uma das versões será descartada. Se a função do seu componente for pura (como deveria
        ser), isso não deverá afetar o comportamento.
      </li>
    </ul>
    <hr>
    <h3>Uso</h3>
    <h4>Referenciando um valor com uma referência</h4>
    <p>
      Chame useRefno nível superior do seu componente para declarar uma ou mais referências.
      <div class="exemplos">
        import { useRef } from 'react'; <br>
        <br>
        function Stopwatch() {<br>
        const intervalRef = useRef(0);<br>
        /....
      </div>
    </p>
    <p>
      useRef retorna um objeto ref com uma única currentpropriedade inicialmente definida com o valor inicial que você
      forneceu.
    </p>
    <p>
      Nas próximas renderizações, useRefretornará o mesmo objeto. Você pode alterar sua currentpropriedade para
      armazenar informações e lê-las mais tarde. Isso pode lembrá-lo de state , mas há uma diferença importante.
    </p>
    <p>
      Alterar uma referência não aciona uma nova renderização. Isso significa que as referências são perfeitas para
      armazenar informações que não afetam a saída visual do seu componente. Por exemplo, se você precisar armazenar um
      ID de intervalo e recuperá-lo posteriormente, poderá colocá-lo em uma ref. Para atualizar o valor dentro da ref,
      você precisa alterar manualmente sua currentpropriedade :
      <div class="exemplos">
        function handleStartClick() {<br>
        const intervalId = setInterval(() => {<br>
        // ...<br>
        }, 1000);<br>
        intervalRef.current = intervalId;<br>
        }<br>
      </div>
    </p>
    <p>
      Posteriormente, você pode ler o ID do intervalo na referência para poder chamar clear that interval :
    </p>
    <div class="exemplos">
      function handleStopClick() {<br>
      const intervalId = intervalRef.current;<br>
      clearInterval(intervalId);<br>
      }
    </div>
    <p>
      Ao usar uma referência, você garante que:
      <ul>
        <li>
          Você pode armazenar informações entre re-renderizações (ao contrário de variáveis ​​regulares, que são
          redefinidas a cada renderização).
        </li>
        <hr>
        <li>
          Alterá-lo não aciona uma nova renderização (ao contrário das variáveis ​​de estado, que acionam uma nova
          renderização).
        </li>
        <hr>
        <li>
          A informação é local para cada cópia do seu componente (ao contrário das variáveis ​​externas, que são
          compartilhadas).
        </li>
        <hr>
        Alterar uma referência não aciona uma nova renderização, portanto as referências não são apropriadas para
        armazenar informações que você deseja exibir na tela. Use state para isso. Leia mais sobre como escolher entre
        useRefe useState.
      </ul>
    </p>

  </section>
</body>

</html>
