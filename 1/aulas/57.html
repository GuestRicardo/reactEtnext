<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../frontend/assets/css/style.css">
  <title>Document</title>

</head>

<body>

  <div>
    <iframe src="../../frontend/assets/pages/menu.html" frameborder="0" class="flame"></iframe>
  </div>
  <section class="container">
    <h1>Children</h1>
    <P>
      Childrenpermite manipular e transformar o JSX que você recebeu como childrensuporte.
      <div class="exemplos">
        const mappedChildren = Children.map(children, child => <br>
        < div className="Row"><br>
          {child}<br>
        </ div><br>
        );
      </div>
    </p>
    <hr>
    <h2>Referência</h2>
    <h3>Children.count(children) </h3>
    <p>
      Chame Children.count(children)para contar o número de filhos na childrenestrutura de dados.
      <div class="exemplos">
        import { Children } from 'react';<br>

        function RowList({ children }) {<br>
        return (<br>
        <><br>
          Total rows: {Children.count(children)}<br>
          ...<br>
          < /><br>
          );<br>
          }
      </div>
    </p>
    <h2>Parâmetros</h2>
    <ul>
      <li>children: O valor da children prop recebida pelo seu componente.</li>
    </ul>
    <h3>Devoluções</h3>
    <p>
      O número de nós dentro destes children.
    </p>
    <h3>Ressalvas</h3>
    <ul>
      <li>
        Nós vazios ( null, undefinede booleanos), strings, números e elementos React contam como nós individuais.
        Matrizes não contam como nós individuais, mas seus filhos sim. A travessia não é mais profunda do que os
        elementos React: eles não são renderizados e seus filhos não são percorridos. Fragmentos não são percorridos.
      </li>
    </ul>
    <hr>
    <h2>Children.forEach(children, fn, thisArg?)</h2>
    <p>
      Chame Children.forEach(children, fn, thisArg?)para executar algum código para cada filho na childrenestrutura de
      dados.
      <img src="../../frontend/assets/img/children1.jpeg" alt="" class="imgZoom">
    </p>
    <h3>Parametros</h3>
    <ul>
      <li>
        children: O valor da childrenprop recebida pelo seu componente.
      </li>
      <li>
        fn: a função de mapeamento, semelhante ao retorno de chamada do método arraymap . Ele será chamado com o filho
        como primeiro argumento e seu índice como segundo argumento. O índice começa 0e aumenta a cada chamada. Você
        precisa retornar um nó React desta função. Pode ser um nó vazio ( null, undefinedou um booleano), uma string, um
        número, um elemento React ou uma matriz de outros nós React.
      </li>
      <li>
        <strong>opcional</strong> thisArg : o thisvalor com o qual a fnfunção deve ser chamada. Se omitido, é undefined.
      </li>
    </ul>
    <h3>Devoluções</h3>
    <p>
      Se childrenfor nullou undefined, retorna o mesmo valor.
    </p>
    <p>
      Caso contrário, retorna uma matriz simples que consiste nos nós que você retornou da fn função. A matriz retornada
      conterá todos os nós retornados, exceto null e undefined.
    </p>
    <h3>
      Ressalvas
    </h3>
    <ul>
      <li>
        Nós vazios ( null, undefinede booleanos), strings, números e elementos React contam como nós individuais.
        Matrizes não contam como nós individuais, mas seus filhos sim. A travessia não é mais profunda do que os
        elementos React: eles não são renderizados e seus filhos não são percorridos. Fragmentos não são percorridos.
      </li>
      <li>
        Se você retornar um elemento ou uma matriz de elementos com chaves from fn, as chaves dos elementos retornados
        serão automaticamente combinadas com a chave do item original correspondente from children. Quando você retorna
        vários elementos de fnuma matriz, suas chaves só precisam ser exclusivas localmente entre si.
      </li>
    </ul>
    <hr>
    <h2>Children.only(children)</h2>
    <p>
      Chame Children.only(children)para afirmar que childrenrepresenta um único elemento React.
      <img src="../../frontend/assets/img/children2.png" alt="" class="imgZoom">
    </p>
    <h3>Parâmetros</h3>
    <ul>
      <li>
        children: O valor da childrenprop recebida pelo seu componente.
      </li>
    </ul>
    <h3>Devoluções</h3>
    <p>
      Se children for um elemento válido, retorna esse elemento. <br>

      Caso contrário, gera um erro.
    </p>
    <h3>Ressalvas</h3>
    <ul>
      <li>Este método sempre é lançado se você passar um array (como o valor de retorno de Children.map) como children.
        Em outras palavras, ele impõe que childrenseja um único elemento React, não que seja um array com um único
        elemento.</li>
    </ul>
    <hr>
    <h2>Children.toArray(children) </h2>
    <p>
      Chame Children.toArray(children)para criar uma matriz fora da childrenestrutura de dados.
    </p>
    <img src="../../frontend/assets/img/children3.png" alt="" class="imgZoom">
    <h3>Parâmetros</h3>
    <ul>
      <li>
        children: O valor da childrenprop recebida pelo seu componente.
      </li>
    </ul>
    <h3>Devoluções</h3>
    <p>
      Retorna uma matriz simples de elementos em children.
    </p>
    <h3>Ressalvas</h3>
    <ul>
      <li>
        Nós vazios ( null, undefinede Booleanos) serão omitidos na matriz retornada. As chaves dos elementos retornados
        serão calculadas a partir das chaves dos elementos originais e seu nível de aninhamento e posição. Isso garante
        que o nivelamento da matriz não introduza mudanças no comportamento.
      </li>
    </ul>
    <hr>
    <h2>Uso</h2>
</body>

</html>
