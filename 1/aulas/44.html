<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../frontend/assets/css/style.css">
  <title>Document</title>

</head>

<body>

  <div>
    <iframe src="../../frontend/assets/pages/menu.html" frameborder="0" class="flame"></iframe>
  </div>
  <section class="container">

    <h1>useReducer</h1>
    <a href="https://react-dev.translate.goog/reference/react/useReducer?_x_tr_sl=en&_x_tr_tl=pt&_x_tr_hl=pt-BR&_x_tr_pto=sc&_x_tr_hist=true"
      style="text-decoration: none;">Fonte: useReducer - React</a>
    <p>
      <strong>useReducer</strong> é um React Hook que permite adicionar um redutor ao seu componente.
    </p>
    <div class="exemplos">
      const [state, dispatch] = useReducer(reducer, initialArg, init?)
    </div>
    <h2>Referência</h2>
    <h4>useReducer(reducer, initialArg, init?) </h4>
    <p>
      Chame useReducero nível superior do seu componente para gerenciar seu estado com um redutor.
      <div class="anotacoes">
        import { useReducer } from 'react'; <br>
        <br>
        function reducer(state, action) {<br>
        // ...<br>
        }<br>
        <br>
        function MyComponent() {<br>
        const [state, dispatch] = useReducer(reducer, { age: 42 });<br>
        // ...
      </div>
    </p>
    <hr>
    <h3>Exemplo feito sem o useContext</h3>
    <p>
      Para entender primeiro sobre esse hook sera preciso entender o q é contexto; quando tem um componente com
      varios outros dentro, para especificar filhos ou irmãos, entã e 8 o seria varias propriedades descendo de niveis e
      por isso se torna inviavel usar dessa forma, pois todos seram instanciados como numa escada(cadeia, o pai
      instancia no filho, o filho 1 instancia no 2 e assim por diante) passando varias props ate chegar no componente
      que deseja exibir. Para evitar essa situação será criado o estado global,onde apartir dele possa se transitar em
      qualquer lugar do codigo atravez do contexto sera passado o estado inicial, usando a propriedade Provider.
    </p>
    <p>
      Com isso os componentes podem ver o contexto para controlar sera o value(valor), que será passado via contexto.
      Entao em resulmo, o contexto recebe o estado inicial para q o componente possa o ver e com useContext esta sendo
      pegado elementos do filho sem precisar de props de forma direta, sendo a vantagem do useContext.
    </p>
    <img src="../../frontend/assets/img/useContext/1.png" alt="" class="zoomImg">
    <div class="lembrete">
      esse exemplo esta sem o useContext
    </div>
    <hr>
    <h3>Exemplo feito com useContext</h3>
    <img src="../../frontend/assets/img/useContext/2.png" alt="" class="zoomImg">
    <img src="../../frontend/assets/img/useContext/3.png" alt="" class="zoomImg">
    <p>

    </p>
    <hr>
    <h4>Parâmetros</h4>
    <ul>
      <li>
        <strong>reducer:</strong> a função redutora que especifica como o estado é atualizado. Deve ser puro, deve tomar
        o estado e a ação como argumentos e deve retornar o próximo estado. Estado e ação podem ser de qualquer tipo.
      </li>
      <li>
        <strong>initialArg:</strong> O valor a partir do qual o estado inicial é calculado. Pode ser um valor de
        qualquer tipo. Como o estado inicial é calculado depende do próximo initargumento.
      </li>
      <li>
        <strong>opcional init:</strong> init : a função inicializadora que deve retornar o estado inicial. Se não for
        especificado, o estado inicial será definido como initialArg. Caso contrário, o estado inicial será definido
        como o resultado da chamada init(initialArg).
      </li>
    </ul>
    <h4>Devoluções</h4>
    <p>
      <strong>useReducer:</strong> retorna um array com exatamente dois valores:
    </p>
    <ol>
      <li>
        O estado atual. Durante a primeira renderização, é definido como init(initialArg)ou initialArg(se não houver
        init).
      </li>
      <li>
        A dispatchfunção que permite atualizar o estado para um valor diferente e acionar uma nova renderização.
      </li>
    </ol>

    <h4>Ressalvas</h4>
    <ul>
      <li>
        <strong>useReducer</strong> é um Hook, então você só pode chamá-lo no nível superior do seu componente ou nos
        seus próprios Hooks. Você não pode chamá-lo dentro de loops ou condições. Se precisar disso, extraia um novo
        componente e mova o estado para ele.
      </li>
      <hr>
      <li>
        No modo estrito, o React chamará seu redutor e inicializador duas vezes para ajudá-lo a encontrar impurezas
        acidentais. Este é um comportamento apenas de desenvolvimento e não afeta a produção. Se o seu redutor e
        inicializador forem puros (como deveriam ser), isso não deverá afetar sua lógica. O resultado de uma das
        chamadas é ignorado.
      </li>
    </ul>
    <hr>
    <h3>dispatch função</h3>
    <p>
      A dispatchfunção retornada por useReducerpermite atualizar o estado para um valor diferente e acionar uma nova
      renderização. Você precisa passar a ação como único argumento para a dispatchfunção:
    </p>
    <div class="exemplos">
      const [state, dispatch] = useReducer(reducer, { age: 42 }); <br>
      <br>
      function handleClick() {<br>
      dispatch({ type: 'incremented_age' });<br>
      // ...
    </div>

    <p>
      O React definirá o próximo estado como o resultado da chamada da reducerfunção que você forneceu com o atual
      statee a ação para a qual você passou dispatch.
    </p>
    <div style="border: solid 3px  rgb(255, 12, 12); padding-left: 25px;">
      <h4>Parâmetros</h4>
      <ul>
        <li>
          <strong>dispatch</strong>
          funções não têm um valor de retorno.
        </li>
      </ul>
    </div>
    <h4>Ressalvas</h4>
    <ul>
      <li>
        A dispatch função apenas atualiza a variável de estado para a próxima renderização . Se você ler a variável de
        estado depois de chamar a dispatchfunção, ainda obterá o valor antigo que estava na tela antes da sua chamada.
      </li>
      <hr>
      <li>
        Se o novo valor fornecido for idêntico ao current state, conforme determinado por uma Object.is comparação, o
        React irá pular a nova renderização do componente e seus filhos. Esta é uma otimização. O React ainda pode
        precisar chamar seu componente antes de ignorar o resultado, mas isso não deve afetar seu código.
      </li>
      <hr>
      <li>
        Atualizações de estado dos lotes do React . Ele atualiza a tela depois que todos os manipuladores de eventos
        foram executados e chamaram suas setfunções. Isso evita múltiplas renderizações durante um único evento. No caso
        raro de você precisar forçar o React a atualizar a tela mais cedo, por exemplo, para acessar o DOM, você pode
        usar flushSync.
      </li>
    </ul>
    <hr>
    <h2>Uso</h2>
    <h3>Adicionando um redutor a um componente</h3>
    <p>
      Chame useReducer no nível superior do seu componente para gerenciar o estado com um redutor.
    </p>
    <div class="exemplos">
      import { useReducer } from 'react'; <br>
      <br>
      function reducer(state, action) {<br>
      // ...<br>
      }<br>
      <br>
      function MyComponent() {<br>
      const [state, dispatch] = useReducer(reducer, { age: 42 });<br>
      // ...
    </div>
    <p>
      <strong>useReducer</strong> retorna um array com exatamente dois itens:
    </p>
    <ol>
      <li>
        O estado atual desta variável de estado, inicialmente definido para o estado inicial que você forneceu.
      </li>
      <li>
        A dispatchfunção que permite alterá-lo em resposta à interação.
      </li>
    </ol>
    <p>
      Para atualizar o que está na tela, chame dispatchcom um objeto representando o que o usuário fez, chamado action :
      <div class="exemplos">
        function handleClick() { <br>
        dispatch({ type: 'incremented_age' }); <br>
        }
      </div>
    </p>

  </section>
</body>

</html>
