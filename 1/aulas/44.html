<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../frontend/assets/css/style.css">
  <title>Document</title>

</head>

<body>

  <div>
    <iframe src="../../frontend/assets/pages/menu.html" frameborder="0" class="flame"></iframe>
  </div>
  <section class="container">

    <h1>useReducer</h1>
    <a href="https://react-dev.translate.goog/reference/react/useReducer?_x_tr_sl=en&_x_tr_tl=pt&_x_tr_hl=pt-BR&_x_tr_pto=sc&_x_tr_hist=true"
      style="text-decoration: none;">Fonte: useReducer - React</a>
    <p>
      <strong>useReducer</strong> é um React Hook que permite adicionar um redutor ao seu componente.
    </p>
    <div class="exemplos">
      const [state, dispatch] = useReducer(reducer, initialArg, init?)
    </div>
    <h2>Referência</h2>
    <h4>useReducer(reducer, initialArg, init?) </h4>
    <p>
      Chame useReducero nível superior do seu componente para gerenciar seu estado com um redutor.
      <div class="anotacoes">
        import { useReducer } from 'react'; <br>
        <br>
        function reducer(state, action) {<br>
        // ...<br>
        }<br>
        <br>
        function MyComponent() {<br>
        const [state, dispatch] = useReducer(reducer, { age: 42 });<br>
        // ...
      </div>
    </p>
    <hr>
    <h3>Exemplo feito sem o useContext</h3>
    <p>
      useReducer é um React Hook que permite adicionar um redutor ao seu componente.

      Ele é muito similar ao useState só que foi projetado para trabalhar com estados complexos que requerem alguma
      logica, em nosso exemplo usamos a condicional switch.
      Reducer é uma função que vai manipular seu estado, lembrando sempre; que usar uma função reducer será preciso
      retornar um estado. A função reducer recebe duas propriedades sendo: o estado atual e o action.
      A função recebe o estado atual e retorna o novo estado. <br>
      <span class="lembrete">
        observação o context geralmente se mais organizado com reduce
      </span> <br>
    </p>
    <p>
      <strong>Dispatch</strong> serve para dispachar coisas(disparar ações, que será feito em nosso exemplo) é comum usar objetos e
      definir o tipo da ação.
      <div class="exemplos">

      </div>
    </p>
    <img src="../../frontend/assets/img/useReducer/useReducer.png" alt="" class="zoomImg">

    <p>

    </p>
    <hr>
    <h4>Parâmetros</h4>
    <ul>
      <li>
        <strong>reducer:</strong> a função redutora que especifica como o estado é atualizado. Deve ser puro, deve tomar
        o estado e a ação como argumentos e deve retornar o próximo estado. Estado e ação podem ser de qualquer tipo.
      </li>
      <li>
        <strong>initialArg:</strong> O valor a partir do qual o estado inicial é calculado. Pode ser um valor de
        qualquer tipo. Como o estado inicial é calculado depende do próximo initargumento.
      </li>
      <li>
        <strong>opcional init:</strong> init : a função inicializadora que deve retornar o estado inicial. Se não for
        especificado, o estado inicial será definido como initialArg. Caso contrário, o estado inicial será definido
        como o resultado da chamada init(initialArg).
      </li>
    </ul>
    <h4>Devoluções</h4>
    <p>
      <strong>useReducer:</strong> retorna um array com exatamente dois valores:
    </p>
    <ol>
      <li>
        O estado atual. Durante a primeira renderização, é definido como init(initialArg)ou initialArg(se não houver
        init).
      </li>
      <li>
        A dispatchfunção que permite atualizar o estado para um valor diferente e acionar uma nova renderização.
      </li>
    </ol>

    <h4>Ressalvas</h4>
    <ul>
      <li>
        <strong>useReducer</strong> é um Hook, então você só pode chamá-lo no nível superior do seu componente ou nos
        seus próprios Hooks. Você não pode chamá-lo dentro de loops ou condições. Se precisar disso, extraia um novo
        componente e mova o estado para ele.
      </li>
      <hr>
      <li>
        No modo estrito, o React chamará seu redutor e inicializador duas vezes para ajudá-lo a encontrar impurezas
        acidentais. Este é um comportamento apenas de desenvolvimento e não afeta a produção. Se o seu redutor e
        inicializador forem puros (como deveriam ser), isso não deverá afetar sua lógica. O resultado de uma das
        chamadas é ignorado.
      </li>
    </ul>
    <hr>
    <h3>dispatch função</h3>
    <p>
      A dispatchfunção retornada por useReducerpermite atualizar o estado para um valor diferente e acionar uma nova
      renderização. Você precisa passar a ação como único argumento para a dispatchfunção:
    </p>
    <div class="exemplos">
      const [state, dispatch] = useReducer(reducer, { age: 42 }); <br>
      <br>
      function handleClick() {<br>
      dispatch({ type: 'incremented_age' });<br>
      // ...
    </div>

    <p>
      O React definirá o próximo estado como o resultado da chamada da reducerfunção que você forneceu com o atual
      statee a ação para a qual você passou dispatch.
    </p>
    <div style="border: solid 3px  rgb(255, 12, 12); padding-left: 25px;">
      <h4>Parâmetros</h4>
      <ul>
        <li>
          <strong>dispatch</strong>
          funções não têm um valor de retorno.
        </li>
      </ul>
    </div>
    <h4>Ressalvas</h4>
    <ul>
      <li>
        A dispatch função apenas atualiza a variável de estado para a próxima renderização . Se você ler a variável de
        estado depois de chamar a dispatchfunção, ainda obterá o valor antigo que estava na tela antes da sua chamada.
      </li>
      <hr>
      <li>
        Se o novo valor fornecido for idêntico ao current state, conforme determinado por uma Object.is comparação, o
        React irá pular a nova renderização do componente e seus filhos. Esta é uma otimização. O React ainda pode
        precisar chamar seu componente antes de ignorar o resultado, mas isso não deve afetar seu código.
      </li>
      <hr>
      <li>
        Atualizações de estado dos lotes do React . Ele atualiza a tela depois que todos os manipuladores de eventos
        foram executados e chamaram suas setfunções. Isso evita múltiplas renderizações durante um único evento. No caso
        raro de você precisar forçar o React a atualizar a tela mais cedo, por exemplo, para acessar o DOM, você pode
        usar flushSync.
      </li>
    </ul>
    <hr>
    <h2>Uso</h2>
    <h3>Adicionando um redutor a um componente</h3>
    <p>
      Chame useReducer no nível superior do seu componente para gerenciar o estado com um redutor.
    </p>
    <div class="exemplos">
      import { useReducer } from 'react'; <br>
      <br>
      function reducer(state, action) {<br>
      // ...<br>
      }<br>
      <br>
      function MyComponent() {<br>
      const [state, dispatch] = useReducer(reducer, { age: 42 });<br>
      // ...
    </div>
    <p>
      <strong>useReducer</strong> retorna um array com exatamente dois itens:
    </p>
    <ol>
      <li>
        O estado atual desta variável de estado, inicialmente definido para o estado inicial que você forneceu.
      </li>
      <li>
        A dispatchfunção que permite alterá-lo em resposta à interação.
      </li>
    </ol>
    <p>
      Para atualizar o que está na tela, chame dispatch com um objeto representando o que o usuário fez, chamado action
      :
      <div class="exemplos">
        function handleClick() { <br>
        dispatch({ type: 'incremented_age' }); <br>
        }
      </div>
    </p>
    <p>
      O React passará o estado atual e a ação para sua função redutora . Seu redutor calculará e retornará o próximo
      estado. O React armazenará o próximo estado, renderizará seu componente com ele e atualizará a UI.
      <div class="exemplos">
        import { useReducer } from 'react'; <br>
        <br>
        function reducer(state, action) {<br>
        if (action.type === 'incremented_age') {<br>
        return {<br>
        age: state.age + 1<br>
        };<br>
        }<br>
        throw Error('Unknown action.');<br>
        }<br>
        <br>
        export default function Counter() {<br>
        const [state, dispatch] = useReducer(reducer, { age: 42 });<br>
        <br>
        return (<br>
        <><br>
          <button onClick={()=> {<br>
            dispatch({ type: 'incremented_age' })<br>
            }}><br>
            Increment age<br>
          </button><br>
          <p>Hello! You are {state.age}.</p><br>
        </><br>
        );<br>
        }
      </div>
    </p>
    <p>
      <strong>useReducer</strong> é muito semelhante a useState, mas permite mover a lógica de atualização de estado dos
      manipuladores de eventos para uma única função fora do seu componente. Leia mais sobre como escolher entre
      useStatee useReducer.
    </p>
    <hr>
    <h2>Escrevendo a função redutora</h2>
    <p>
      uma função redutora é declarada assim:
      <div class="exemplos">
        function reducer(state, action) { <br>
        // ...<br>
        }
      </div>
    </p>
    <p>
      Depois você precisa preencher o código que irá calcular e retornar o próximo estado. Por convenção, é comum
      escrevê-lo como uma switchdeclaração. Para cada um caseno switch, calcule e retorne o próximo estado.
      <div class="exemplos">
        function reducer(state, action) {<br>
        switch (action.type) {<br>
        case 'incremented_age': {<br>
        return {<br>
        name: state.name,<br>
        age: state.age + 1<br>
        };<br>
        }<br>
        case 'changed_name': {<br>
        return {<br>
        name: action.nextName,<br>
        age: state.age<br>
        };<br>
        }<br>
        }<br>
        throw Error('Unknown action: ' + action.type);<br>
        }
      </div>
    </p>
    <p>
      As ações podem ter qualquer formato. Por convenção, é comum passar objetos com uma typepropriedade que identifica
      a ação. Deve incluir as informações mínimas necessárias que o redutor precisa para calcular o próximo estado.
      <div class="exemplos">
        function Form() {<br>
        const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });<br>
        <br>
        function handleButtonClick() {<br>
        dispatch({ type: 'incremented_age' });<br>
        }<br>
        <br>
        function handleInputChange(e) {<br>
        dispatch({<br>
        type: 'changed_name',<br>
        nextName: e.target.value<br>
        });<br>
        }<br>
        // ...
      </div>
    </p>
    <p>
      Os nomes dos tipos de ação são locais para o seu componente. Cada ação descreve uma única interação, mesmo que
      isso leve a diversas alterações nos dados. A forma do estado é arbitrária, mas geralmente será um objeto ou um
      array. <br>

      Leia extraindo lógica de estado em um redutor para saber mais.
      <div class="lembrete">
        <h2>Armadilha</h2>
        <p>
          O estado é somente leitura. Não modifique nenhum objeto ou array no estado:
        </p>
        <div class="exemplos">
          function reducer(state, action) { <br>
          switch (action.type) {<br>
          case 'incremented_age': {<br>
          // 🚩 Don't mutate an object in state like this:<br>
          state.age = state.age + 1;<br>
          return state;<br>
          }
        </div>
        Em vez disso, sempre retorna novos objetos do seu rodutor:
        <div class="exemplos">
          function reducer(state, action) { <br>
          switch (action.type) { <br>
          case 'incremented_age': { <br>
          // ✅ Instead, return a new object <br>
          return { <br>
          ...state, <br>
          age: state.age + 1 <br>
          }; <br>
          }
        </div>

      </div>
    </p>
  </section>
</body>

</html>
