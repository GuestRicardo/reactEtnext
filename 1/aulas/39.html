<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../frontend/assets/css/style.css">
  <title>Document</title>

</head>

<body>

  <div>
    <iframe src="../../frontend/assets/pages/menu.html" frameborder="0" class="flame"></iframe>
  </div>
  <section class="container">

    <h1>useEffect</h1>
    <p> <a href="https://pt-br.legacy.reactjs.org/docs/hooks-effect.html"
        style="text-decoration: none; color: brown;"><strong>Fonte dessa materia abaixo</strong></a>
    </p>
    <p>
      O Effect Hook (Hook de Efeito) te permite executar efeitos colaterais em componentes funcionais:
      <img src="../../frontend/assets/img/useEffect/1.1.png" alt="" class="zoomImg" />
    </p>
    <p>
      Esse trecho de código é baseado no exemplo de contador da página anterior, mas nós adicionamos uma nova
      funcionalidade a ele: nós definimos o título do documento para ser uma mensagem customizada que inclua o número de
      cliques.
    </p>
    <p>
      Buscar dados, configurar uma subscription, e mudar o DOM manualmente dentro dos componentes React são exemplos de
      efeitos colaterais. Esteja você acostumado ou não a chamar essas operações de “efeitos colaterais” (ou somente
      “efeitos”), você provavelmente já usou eles em seus componentes antes.
    </p>
    <div class="lembrete">
      <strong>Dica</strong><br>
      Se você está familiarizado com os métodos do ciclo de vida do React, você pode pensar no Hook useEffect como
      componentDidMount, componentDidUpdate, e componentWillUnmount combinados.
    </div>
    <div>
      Existem dois tipos comuns de efeitos colaterais nos componentes React: aqueles que não precisam de limpeza, e
      aqueles que precisam. Vamos ver as suas diferenças mais detalhadamente.
    </div>
    <hr>
    <h2>Efeitos Sem Limpeza</h2>
    <p>
      De vez em quando, nós queremos executar algum código adicional depois que o React atualizou a DOM. Requisições,
      mutações manuais do DOM e log são exemplos comuns de efeitos que não precisam de limpeza. Nós dizemos isso porque
      podemos executa-los e imediatamente esquecer deles. Vamos comparar como classes e Hooks nos permitem expressar
      tais efeitos colaterais.
    </p>
    <h3>Exemplo usando Classes</h3>
    <p>
      Em um componente de classe do React, o método render não deve causar efeitos colaterais. Seria muito cedo — nós
      geralmente queremos executar nossos efeitos depois que o React atualizou a DOM.
    </p>
    <p>
      Isso é o porque nas classes do React, nós colocamos efeitos dentro de componentDidMount e componentDidUpdate.
      Voltando ao nosso exemplo, aqui está um componente de classe do React chamado contador que atualiza o título logo
      após o React faz as mudanças na DOM:
      <img src="../../frontend/assets/img/useEffect/1.2.png" alt="" class="zoomImg" />
      Note que nós temos que duplicar o código entre esses dois métodos do ciclo de vida na classe.
    </p>
    <p>
      Isso acontece porque em muitos casos nós queremos executar o mesmo efeito colateral não importando se o componente
      acabou de ser montado ou foi atualizado. Conceitualmente, nós queremos que isso aconteça em cada renderização —
      mas componentes de classe do React não tem um método assim. Nós poderíamos extrair um método separado mas ainda
      assim teríamos que chamá-lo em dois lugares.
      <br>
      Agora vamos ver como podemos fazer a mesma coisa com o Hook useEffect.


    </p>
    <h1>useEffect PARTE 2</h1>
    <p>
      <a href="https://www.treinaweb.com.br/blog/react-conheca-o-poder-dos-hooks#:~:text=O%20useEffect()%20recebe%20como,que%20o%20componente%20for%20atualizado."
        style="text-decoration: none; color: brown;"><strong>Fonte dessa materia abaixo</strong></a>
    </p>
    <p>
      O useEffect é um Hook que serve para lidar com os efeitos. Podemos usá-los como os <span
        style="color: brown;">lifeCycles componentDidMount,
        componentDidUpdate e componentWillUnmount.</span>

      Imagine que a gente tenha uma API que nos retorna uma lista de produtos baseado no nome que passarmos.
      <img src="../../frontend/assets/img/useEffect/1.png" alt="" class="zoomImg">

    </p>
    <p>
      O useEffect() recebe como primeiro parâmetro uma função que será executada assim que o componente renderizar.
      Então é um ótimo lugar para fazer requisições.

      Dessa maneira como escrevemos, a função passada ao useEffect() será executada sempre que o componente for
      atualizado.
      <img src="../../frontend/assets/img/useEffect/2.png" alt="" class="zoomImg">
      E se quisermos que a função seja executada apenas uma vez, que é quando o componente é inserido na tela, basta
      passar um Array vazio.
    </p>
    <p>
      <img src="../../frontend/assets/img/useEffect/3.png" alt="" class="zoomImg">
      Você pode executar quantos useEffects() quiser, o que nos dá mais controle sobre o que e quando algo deve ser
      executado.
    </p>

  </section>

</body>

</html>
